\documentclass[12pt,onecolumn,a4paper]{article}
\usepackage{epsfig,graphicx,subfigure,amsthm,amsmath}
\usepackage{color,xcolor}
\usepackage{fancyvrb}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{lscape}
\usepackage{booktabs}
\usepackage{xepersian}
\settextfont[Scale=1.0]{Far.Roya}
\setlatintextfont[Scale=1]{Times New Roman Cyr}

\begin{document}

\begin{titlepage}
\title{تمرین چهارم رایانش چندهسته‌ای \\ بخش عملی} 
\author{نوید اسلامی - 98100323 \\ سروش جهان‌زاد - 98100389}
\date{\today}
\maketitle
\end{titlepage}

\section*{\lr{CUDA Warm-up}}
پاسخ مربوط به این سؤال را می‌توانید در پوشه‌ی \lr{Code/3} به همراه دو عکس و یک کد \lr{C++} معمولی برای مقایسه ببینید. همانطور که در کد \lr{Code.cu} مشاهده می‌شود، در پیاده‌سازی این الگوریتم از تکنیک‌های بهبود \lr{Cache Locality} با تنظیم دسترسی‌های ریسه‌ها نزدیک به هم استفاده شده است. همچنین، برای این که از پهنای باند حافظه به خوبی استفاده کنیم، از تکنیک \lr{Loop Unrolling} نیز استفاده شده است. در نهایت، همه‌ی این تکنیک‌ها را با استفاده از بلوک‌های مختلف روی \lr{SM}های مختلف سخت‌افزار اجرا کرده‌ایم تا بهترین عملکرد را داشته باشیم. برای محاسبه‌ی \lr{Inversion} نیز از این موضوع استفاده کردیم که مقدار $255 - x$ برای یک $x$ 8 بیتی، معادل این است که از آن \lr{Ones Complement} بگیریم. در نتیجه، کد سطح پایین را با استفاده از این عمل سریع‌تر و ساده‌تر کردیم. همانطور که از خروجی این کد مشاهده می‌شود، به درستی و با سرعت بالا می‌توانیم یک تصویر را نگاتیو کنیم.

\section*{\lr{SIMD in Action! Part 2}}
پاسخ مربوط به این سؤال را می‌توانید در پوشه‌ی \lr{Code/4} به همراه فایل‌های مربوط به همین سؤال تمرین قبل ببینید. همانور که در کد \lr{Code.cu} مشاهده می‌شود، با منطقی مشابه سؤال قبل، وظیفه‌ی هندل کردن هر پیکسل را به یک ریسه داده‌ایم و با استفاده از تعریف چند بلوک، از توان تمام \lr{SM}ها استفاده کرده‌ایم. همچنین، برای این که مشکل \lr{Divergence} را نداشته باشیم، با استفاده از \lr{Bit Magic} روابط بیتی‌ای نوشته‌ایم که عملگر انتخاب مقدار را با منطقی مشابه با یک \lr{Multiplexer} به صورت \lr{Branch-Free} محاسبه کند. در نتیجه، همیشه \lr{Utilization} بالایی در این برنامه خواهیم داشت. اما برای سادگی کد و بنا به این موضوع که کلاً در این کاربرد استفاده از پهنای باند حافظه به دلیل محاسبات عالی نخواهد بود، از تکنیک \lr{Loop Unrolling} استفاده نکرده‌ایم.

توجه کنید که برای این موضوع لازم داشتیم که یک \lr{Mask} داشته باشیم که یا همه یک و یا همه صفر باشد. در نتیجه،‌ مقدار شرط را محاسبه می‌کنیم و در یک متغیر \lr{char} ذخیره می‌کنیم. سپس با منفی کردن این متغیر، اگر مقدار آن یک بود به همه یک در نمایش بیتی تبدیل می‌شود و در غیر این صورت، همان صفر می‌ماند. در نتیجه، با استفاده از این متغیر می‌توانیم منطق \lr{Multiplexer} را ایجاد کنیم و با سرعت و بهره‌وری بالایی محاسبات را انجام دهیم. همانطور که مشاهده می‌شود، خروجی‌ای که توسط این برنامه تولید می‌شود به همان شکلی است که توسط \lr{main.c} ایجاد می‌شود. پس می‌فهمیم که کد ما رفتار درستی دارد و به هدف مسئله رسیده‌ایم.

\end{document}